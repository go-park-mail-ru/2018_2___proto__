
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">proto-game-server/api/apiresponse_easyjson.go (0.0%)</option>
				
				<option value="file1">proto-game-server/api/apiservice.go (0.0%)</option>
				
				<option value="file2">proto-game-server/api/configs.go (0.0%)</option>
				
				<option value="file3">proto-game-server/api/scanner.go (0.0%)</option>
				
				<option value="file4">proto-game-server/api/scores.go (0.0%)</option>
				
				<option value="file5">proto-game-server/api/sessions.go (0.0%)</option>
				
				<option value="file6">proto-game-server/api/users.go (14.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package api

import (
        json "encoding/json"
        easyjson "github.com/mailru/easyjson"
        jlexer "github.com/mailru/easyjson/jlexer"
        jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
        _ *json.RawMessage
        _ *jlexer.Lexer
        _ *jwriter.Writer
        _ easyjson.Marshaler
)

func easyjson40f06b4fDecodeProtoGameServerApi(in *jlexer.Lexer, out *ApiResponse) <span class="cov0" title="0">{
        isTopLevel := in.IsStart()
        if in.IsNull() </span><span class="cov0" title="0">{
                if isTopLevel </span><span class="cov0" title="0">{
                        in.Consumed()
                }</span>
                <span class="cov0" title="0">in.Skip()
                return</span>
        }
        <span class="cov0" title="0">in.Delim('{')
        for !in.IsDelim('}') </span><span class="cov0" title="0">{
                key := in.UnsafeString()
                in.WantColon()
                if in.IsNull() </span><span class="cov0" title="0">{
                        in.Skip()
                        in.WantComma()
                        continue</span>
                }
                <span class="cov0" title="0">switch key </span>{
                case "Code":<span class="cov0" title="0">
                        out.Code = int(in.Int())</span>
                case "Response":<span class="cov0" title="0">
                        if m, ok := out.Response.(easyjson.Unmarshaler); ok </span><span class="cov0" title="0">{
                                m.UnmarshalEasyJSON(in)
                        }</span> else<span class="cov0" title="0"> if m, ok := out.Response.(json.Unmarshaler); ok </span><span class="cov0" title="0">{
                                _ = m.UnmarshalJSON(in.Raw())
                        }</span> else<span class="cov0" title="0"> {
                                out.Response = in.Interface()
                        }</span>
                default:<span class="cov0" title="0">
                        in.SkipRecursive()</span>
                }
                <span class="cov0" title="0">in.WantComma()</span>
        }
        <span class="cov0" title="0">in.Delim('}')
        if isTopLevel </span><span class="cov0" title="0">{
                in.Consumed()
        }</span>
}
func easyjson40f06b4fEncodeProtoGameServerApi(out *jwriter.Writer, in ApiResponse) <span class="cov0" title="0">{
        out.RawByte('{')
        first := true
        _ = first
        </span><span class="cov0" title="0">{
                const prefix string = ",\"Code\":"
                if first </span><span class="cov0" title="0">{
                        first = false
                        out.RawString(prefix[1:])
                }</span> else<span class="cov0" title="0"> {
                        out.RawString(prefix)
                }</span>
                <span class="cov0" title="0">out.Int(int(in.Code))</span>
        }
        <span class="cov0" title="0">{
                const prefix string = ",\"Response\":"
                if first </span><span class="cov0" title="0">{
                        first = false
                        out.RawString(prefix[1:])
                }</span> else<span class="cov0" title="0"> {
                        out.RawString(prefix)
                }</span>
                <span class="cov0" title="0">if m, ok := in.Response.(easyjson.Marshaler); ok </span><span class="cov0" title="0">{
                        m.MarshalEasyJSON(out)
                }</span> else<span class="cov0" title="0"> if m, ok := in.Response.(json.Marshaler); ok </span><span class="cov0" title="0">{
                        out.Raw(m.MarshalJSON())
                }</span> else<span class="cov0" title="0"> {
                        out.Raw(json.Marshal(in.Response))
                }</span>
        }
        <span class="cov0" title="0">out.RawByte('}')</span>
}

// MarshalJSON supports json.Marshaler interface
func (v ApiResponse) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        w := jwriter.Writer{}
        easyjson40f06b4fEncodeProtoGameServerApi(&amp;w, v)
        return w.Buffer.BuildBytes(), w.Error
}</span>

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v ApiResponse) MarshalEasyJSON(w *jwriter.Writer) <span class="cov0" title="0">{
        easyjson40f06b4fEncodeProtoGameServerApi(w, v)
}</span>

// UnmarshalJSON supports json.Unmarshaler interface
func (v *ApiResponse) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        r := jlexer.Lexer{Data: data}
        easyjson40f06b4fDecodeProtoGameServerApi(&amp;r, v)
        return r.Error()
}</span>

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *ApiResponse) UnmarshalEasyJSON(l *jlexer.Lexer) <span class="cov0" title="0">{
        easyjson40f06b4fDecodeProtoGameServerApi(l, v)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "database/sql"
        "fmt"

        "google.golang.org/grpc"

        m "proto-game-server/models"
        _ "github.com/lib/pq"
)

type ApiService struct {
        Sessions m.AuthClient
        Users    IUserStorage
        Scores   IScoreStorage
}

func NewApiService(cfg *ServerConfig) (*ApiService, error) <span class="cov0" title="0">{
        fmt.Println(cfg.DbConnectionString)

        db, err := sql.Open(cfg.DbConnector, cfg.DbConnectionString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // defer db.Close()

        // TODO: fix later
        <span class="cov0" title="0">authClientConn, err := grpc.Dial(
                cfg.AuthServiceHost,
                grpc.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        //defer authClientConn.Close()

        <span class="cov0" title="0">service := &amp;ApiService{
                Users:    NewUserStorage(db),
                Sessions: m.NewAuthClient(authClientConn),
                Scores:   NewScoreStorage(db),
        }

        return service, nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "encoding/json"
        "io/ioutil"
)

//это конфиги для старой сборки сервера, нужно буддет потом структуру поменять
type ServerConfig struct {
        DbConnector        string `json:"dbconnector"`
        DbConnectionString string `json:"connectionstring"`
        CorsAllowedHost    []string `json:"corsallowedhost"`
        UseHTTPS           bool   `json:"https"`
        Port               string `json:"port"`
        StaticRoot         string `json:"staticroot"`
        AuthServiceHost    string `json:"authservicehost"`
        PprofEnabled       bool   `json:"pprofenabled"`
}

func LoadConfigs(path string) (*ServerConfig, error) <span class="cov0" title="0">{
        cfg := new(ServerConfig)

        content, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(content, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        m "proto-game-server/models"
)

type IRow interface {
        Scan(dest ...interface{}) error
}

func ScanUserFromRow(row IRow) (*m.User, error) <span class="cov0" title="0">{
        user := new(m.User)
        err := row.Scan(&amp;user.Id, &amp;user.Nickname, &amp;user.Password, &amp;user.Fullname, &amp;user.Email, &amp;user.Avatar)

        return user, err
}</span>

func ScanSessionFromRow(row IRow) (*m.Session, error) <span class="cov0" title="0">{
        session := new(m.Session)
        user := new(m.User)
        session.User = user
        err := row.Scan(&amp;session.Id, &amp;session.Token, &amp;session.User.Id, &amp;session.TTL,
                &amp;session.User.Id, &amp;session.User.Nickname, &amp;session.User.Password,
                &amp;session.User.Fullname, &amp;session.User.Email, &amp;session.User.Avatar)
        return session, err
}</span>

func ScanScoreFromRow(row IRow) (*m.ScoreRecord, error) <span class="cov0" title="0">{
        scoreRecord := new(m.ScoreRecord)
        err := row.Scan(&amp;scoreRecord.Id, &amp;scoreRecord.Score, &amp;scoreRecord.Nickname)
        return scoreRecord, err
}</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "database/sql"
        "net/http"
        m "proto-game-server/models"
)

type IScoreStorage interface {
        Get(offset int, limit int) *ApiResponse
}

type ScoreStorage struct {
        db *sql.DB
}

func NewScoreStorage(db *sql.DB) *ScoreStorage <span class="cov0" title="0">{
        return &amp;ScoreStorage{db}
}</span>

func ReadScoreRecords(rows *sql.Rows, usedOffset int) (*m.ScoreRecords, error) <span class="cov0" title="0">{
        scores := make([]*m.ScoreRecord, 0)

        for rows.Next() </span><span class="cov0" title="0">{
                scoreRecord, err := ScanScoreFromRow(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">scores = append(scores, scoreRecord)</span>
        }

        <span class="cov0" title="0">scoreRecords := &amp;m.ScoreRecords{
                Count:   len(scores),
                Offset:  usedOffset,
                Records: scores,
        }

        return scoreRecords, nil</span>
}

func (s *ScoreStorage) Get(offset int, limit int) *ApiResponse <span class="cov0" title="0">{
        rows, err := s.db.Query(`WITH scores AS (
                SELECT id, score, player_id 
                FROM score
                ORDER BY score DESC, id ASC
                LIMIT $1 OFFSET $2
        )
        
        SELECT s.id, s.score, p.nickname
        FROM scores AS s
        INNER JOIN player AS p ON p.id=s.player_id`,
                limit,
                offset,
        )

        if err != nil </span><span class="cov0" title="0">{
                return &amp;ApiResponse{Code: http.StatusInternalServerError, Response: err}
        }</span>

        <span class="cov0" title="0">scoresRecords, err := ReadScoreRecords(rows, offset)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ApiResponse{Code: http.StatusBadRequest, Response: err}
        }</span>

        <span class="cov0" title="0">return &amp;ApiResponse{Code: http.StatusOK, Response: scoresRecords}</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "database/sql"
        "errors"
        "log"
        "time"

        m "proto-game-server/models"

        "github.com/satori/go.uuid"
)

type ISessionStorage interface {
        //создает сессию для пользователя
        //использовать для авторизации
        Create(user *m.User) (string, error)

        //уничтожает сессиию
        //использовать при выходе из системы
        Remove(session *m.Session) (*m.Session, error)

        //возвращает сессию и флаг найдена она или нет
        //нужно будет использовать эту функцию при аутентификации
        GetById(id string) (*m.Session, error)
}

type SessionStorage struct {
        db *sql.DB
}

func NewSessionStorage(db *sql.DB) *SessionStorage <span class="cov0" title="0">{
        return &amp;SessionStorage{db: db}
}</span>

// выдача куки при авторизации
func (s *SessionStorage) Create(user *m.User) (string, error) <span class="cov0" title="0">{
        row := s.db.QueryRow(
                "SELECT id, nickname, password, fullname, email, avatar FROM player WHERE nickname=$1",
                user.Nickname)
        expectedUser, err := ScanUserFromRow(row)

        if err != nil </span><span class="cov0" title="0">{
                log.Print(err)
                return "", err
        }</span>

        <span class="cov0" title="0">if expectedUser.Password != user.Password </span><span class="cov0" title="0">{
                return "", errors.New("invalid passwred")
        }</span>

        <span class="cov0" title="0">UUID := uuid.NewV4()
        sessionToken := UUID.String()
        var oldToken string
        var ttl int64
        expirationDate := time.Now().Unix() + 86400

        _, err = s.db.Exec("INSERT INTO user_session(token, player_id, expired_date) VALUES ($1, $2, $3);",
                sessionToken, expectedUser.Id, expirationDate)
        if err != nil </span><span class="cov0" title="0">{
                log.Print(err.Error())
                row = s.db.QueryRow(
                        "SELECT token, expired_date FROM user_session WHERE player_id=$1",
                        expectedUser.Id)
                err = row.Scan(&amp;oldToken, &amp;ttl)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if ttl &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                        _, err = s.db.Exec("DELETE FROM user_session WHERE token=$1;", oldToken)
                        _, err = s.db.Exec("INSERT INTO user_session(token, player_id, expired_date) VALUES ($1, $2, $3);", sessionToken, expectedUser.Id, expirationDate)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", errors.New("session is already dead")
                        }</span>
                } else<span class="cov0" title="0"> {
                        sessionToken = oldToken
                }</span>
        }

        <span class="cov0" title="0">log.Println("\nreturned sessionID ", sessionToken)
        return sessionToken, nil</span>
}

func (s *SessionStorage) Remove(session *m.Session) (*m.Session, error) <span class="cov0" title="0">{
        _, err := s.db.Exec(`DELETE FROM user_session WHERE token=$1`,
                session.Token,
        )

        return session, err;
}</span>

func (s *SessionStorage) GetById(token string) (*m.Session, error) <span class="cov0" title="0">{
        row := s.db.QueryRow(`SELECT s.id, s.token, s.player_id, s.expired_date, p.id,
        p.nickname, p.password, p.fullname, p.email, p.avatar
                FROM user_session s
                INNER JOIN player p
                on s.player_id = p.id
                WHERE token=$1;`,
                token,
        )

        session, err := ScanSessionFromRow(row)
        return session, err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "database/sql"
        "net/http"

        m "proto-game-server/models"

        validate "github.com/asaskevich/govalidator"
)

type IUserStorage interface {
        Add(user *m.User) *ApiResponse

        Remove(user *m.User) *ApiResponse

        Update(user *m.User) *ApiResponse

        Get(slug string) *ApiResponse
}

type UserStorage struct {
        db *sql.DB
}

func NewUserStorage(db *sql.DB) *UserStorage <span class="cov8" title="1">{
        return &amp;UserStorage{db}
}</span>

// nice func to remove repeating code
func ThrowAPIError(code int32, message string) *ApiResponse <span class="cov8" title="1">{
        return &amp;ApiResponse{
                Code: int(code),
                Response: &amp;m.Error{
                        Code:    code,
                        Message: message}}
}</span>

func ValidateUser(user *m.User) (err error) <span class="cov0" title="0">{
        // this defer catches panics from smtp module

        // user fields validation
        _, err = validate.ValidateStruct(user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check if the email is resolvable
        // err = checkmail.ValidateHost(user.Email)
        // if err != nil {
        //         return err
        // }

        <span class="cov0" title="0">return nil</span>
}

func (u *UserStorage) Add(user *m.User) *ApiResponse <span class="cov8" title="1">{

        _, err := u.db.Exec(
                "INSERT INTO player(nickname, password, email) VALUES ($1,$2,$3);",
                user.Nickname, user.Password, user.Email)

        if err != nil </span><span class="cov8" title="1">{
                return ThrowAPIError(http.StatusConflict, err.Error())
        }</span>

        // user.Id, _ = result.LastInsertId()
        <span class="cov8" title="1">return &amp;ApiResponse{Code: http.StatusCreated, Response: user}</span>
}

// FIXME: remove user's session
func (u *UserStorage) Remove(user *m.User) *ApiResponse <span class="cov0" title="0">{

        // это работает в консоли pgsql, но не работает тут ¯\_(ツ)_/¯
        _, err := u.db.Exec(
                "DELETE FROM player WHERE id=$1;", user.Id)
        print(err.Error())
        if err != nil </span><span class="cov0" title="0">{
                return ThrowAPIError(http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;ApiResponse{
                Code:     http.StatusGone,
                Response: "User removed."}</span>
}

// TODO: this funs is untested
func (u *UserStorage) Update(user *m.User) *ApiResponse <span class="cov0" title="0">{
        if _, err := validate.ValidateStruct(user); err != nil </span><span class="cov0" title="0">{
                return ThrowAPIError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">row := u.db.QueryRow("SELECT id, nickname, password, fullname, email, avatar FROM player WHERE id=$1", user.Id)
        oldUser, err := ScanUserFromRow(row)

        if err != nil </span><span class="cov0" title="0">{
                ThrowAPIError(http.StatusNotFound, err.Error())
        }</span>

        <span class="cov0" title="0">if user.Nickname == "" </span><span class="cov0" title="0">{
                user.Nickname = oldUser.Nickname
        }</span>

        <span class="cov0" title="0">if user.Fullname == "" </span><span class="cov0" title="0">{
                user.Fullname = oldUser.Fullname
        }</span>

        <span class="cov0" title="0">if user.Password == "" </span><span class="cov0" title="0">{
                user.Password = oldUser.Password
        }</span>

        <span class="cov0" title="0">if user.Email == "" </span><span class="cov0" title="0">{
                user.Email = oldUser.Email
        }</span>

        <span class="cov0" title="0">if user.Avatar == "" </span><span class="cov0" title="0">{
                user.Avatar = oldUser.Avatar
        }</span>

        <span class="cov0" title="0">_, err = u.db.Exec("UPDATE player SET nickname=$1, fullname=$2, password=$3, email=$4, avatar=$5 WHERE id=$5",
                user.Nickname, user.Fullname, user.Password, user.Email, user.Id, user.Avatar)
        if err != nil </span><span class="cov0" title="0">{
                return ThrowAPIError(http.StatusConflict, err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;ApiResponse{
                Code:     http.StatusOK,
                Response: user,
        }</span>
}

// TODO: method for recieving user's info
func (u *UserStorage) Get(slug string) *ApiResponse <span class="cov0" title="0">{
        // TODO: add check for "id" substring in order to search for id

        row := u.db.QueryRow("SELECT id, nickname, email, fullname, avatar FROM player WHERE nickname=$1", slug)
        user := new(m.User)
        err := row.Scan(&amp;user.Id, &amp;user.Nickname, &amp;user.Email, &amp;user.Fullname, &amp;user.Avatar)
        if err != nil </span><span class="cov0" title="0">{
                return ThrowAPIError(http.StatusNotFound, err.Error())
        }</span>
        <span class="cov0" title="0">return &amp;ApiResponse{
                Code:     http.StatusOK,
                Response: user,
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
